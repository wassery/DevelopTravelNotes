（1）一个Asset可以有多个Object。Asset有一个File GUID，也就是说Asset里的Object是共用这个File GUID，而这些Object以Local ID来区分。当实例Object时，PersistentManager根据File GUID和Local ID生成一个Instance ID。
> As any given Asset file may contain (or produce via import) multiple UnityEngine.Object resources, a Local ID is required to unambiguously distinguish each distinct Object.
>
>  Each of these Objects will share a File GUID as their source data is stored within the same Asset file. 
>
> Unity internally maintains a cache(Internally, this cache is called the PersistentManager) that translates File GUIDs and Local IDs into simple, session-unique integers. These are called Instance IDs, and are assigned in a simple, monotonically-increasing order when new Objects are registered with the cache.

备注：打开*.meta文件里可以看到guid，但Local ID就没看到，以一个打包成图集的图片Asset为例，可以发现fileIDToRecycleName应该就是这个Local IDs。然而这个属性不是必然的。

（2）打成AssetBundle的Object在调用AssetBundle.Unload(false)，只会被卸载但不会从内存中移除，可以应用在这种需求：APP先被挂起并且强制退入后台，再返回到前台，然后Unity会在Scene恢复渲染前把全部所需的纹理、着色器和网格重新加载到GPU。
> If AssetBundle.Unload(false) is called, live Objects sourced from the unloaded AssetBundle will not be destroyed, but Unity will invalidate the File GUID and Local ID references of their Instance IDs. It will be impossible for Unity to reload these Objects if they are later unloaded from memory and live references to the unloaded Objects remain.
>
> The most common case where Objects are removed from memory at runtime without being unloaded occurs when Unity loses control of its graphics context. This may occur when a mobile app is suspended and the app is forced into the background. In this case, the mobile OS usually evicts all graphical resources from GPU memory. When the app returns to the foreground, Unity must reload all needed Textures, Shaders and Meshes to the GPU before scene rendering can resume.

（3）从存储设备读取预制体，哪怕是相同数据，也要重新进行读取文件，另外这种方法的加载操作受到存储设备I/O时间的限制，所以从内存中读取更优。
> when loading prefabs on platforms with slow storage, the time spent reading the prefab's serialized data from storage can rapidly exceed the time spent instantiating the prefab. That is, the cost of the loading operation is bound to storage I/O time.
>
> when serializing a monolithic prefab, every GameObject and component's data is serialized separately, which may duplicate data.

备注：我的理解就是说AssetBundle比Resources优。

（4）因为大多平台用平衡查找树的数据结构，而时间复杂度为O(nlog(n))。简而言之，AssetBundle比Resources优+1。
> On most platforms, the lookup data structure is a balanced search tree, which has a construction time that grows at an O(n log(n)) rate. This growth also causes the index's loading time to grow more-than-linearly as the number of Objects in Resources folders increases.

（5）对于由AssetBundle序列化的Asset的原始数据选择压缩方案：使用LZMA会统一压缩各个序列化的Asset；使用LZ4会单独压缩各个序列化的Asset。
> the raw data generated by serializing the Assets in the AssetBundle. If LZMA is specified as the compression scheme, the complete byte array for all serialized assets is compressed. If LZ4 is instead specified, bytes for separate Assets are individually compressed. 

备注：我的理解就是说LZ4比LZMA灵活。

（6）由于在Unity的2017.1版本之后，WWW.LoadFromCacheOrDownload 封装到UnityWebRequest中。那么之后应该使用UnityWebRequest。
> *Note: Beginning in Unity 2017.1, WWW.LoadFromCacheOrDownload simply wraps around UnityWebRequest. Accordingly, developers using Unity 2017.1 or higher should migrate to UnityWebRequest. WWW.LoadFromCacheOrDownload will be deprecated in a future release. *

（7）加载AssetBundle，优先使用 AssetBundle.LoadFromFile，因为其速度、磁盘使用和运行时内存占用方面都很高效。当项目需要下载AssetBundle则用UnityWebRequest（因为WWW在以后逐步被弃用）。
> In general, AssetBundle.LoadFromFile should be used whenever possible. This API is the most efficient in terms of speed, disk usage and runtime memory usage.
>
> For projects that must download or patch AssetBundles, it is strongly recommended to use UnityWebRequest for projects using Unity 5.3 or newer

（8）第四篇只是略过......

以上简单回顾。

### 参考地址：

原文：

Assets, Objects and serialization

https://unity3d.com/learn/tutorials/topics/best-practices/assets-objects-and-serialization

The Resources folder

https://unity3d.com/learn/tutorials/topics/best-practices/resources-folder?playlist=30089

AssetBundle fundamentals

https://unity3d.com/learn/tutorials/topics/best-practices/assetbundle-fundamentals?playlist=30089

AssetBundle usage patterns

https://unity3d.com/learn/tutorials/topics/best-practices/assetbundle-usage-patterns?playlist=30089

译文：

Unity资源管理（一）-资源（Assets）、对象（Objects）和序列化

https://blog.csdn.net/qq_21397217/article/details/80500276

Unity资源管理（二）-Resources文件夹

https://blog.csdn.net/qq_21397217/article/details/80542155

Unity资源管理（三）-AssetBundle基本原理

https://blog.csdn.net/qq_21397217/article/details/80571819

Unity资源管理（四）-AssetBundle使用模式

https://blog.csdn.net/qq_21397217/article/details/80586867
