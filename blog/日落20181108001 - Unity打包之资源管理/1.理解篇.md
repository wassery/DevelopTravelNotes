### 参考：

Unity资源管理（一）-资源（Assets）、对象（Objects）和序列化

https://blog.csdn.net/qq_21397217/article/details/80500276

Unity资源管理（二）-Resources文件夹

https://blog.csdn.net/qq_21397217/article/details/80542155

Unity资源管理（三）-AssetBundle基本原理

https://blog.csdn.net/qq_21397217/article/details/80571819

Unity资源管理（四）-AssetBundle使用模式

https://blog.csdn.net/qq_21397217/article/details/80586867

### 笔记：

（1）一个Asset可以有多个Object。Asset有一个File GUID，也就是说Asset里的Object是共用这个File GUID，而这些Object以Local ID来区分。当实例Object时，PersistentManager根据File GUID和Local ID生成一个Instance ID。
> As any given Asset file may contain (or produce via import) multiple UnityEngine.Object resources, a Local ID is required to unambiguously distinguish each distinct Object.
>
>  Each of these Objects will share a File GUID as their source data is stored within the same Asset file. 
>
> Unity internally maintains a cache(Internally, this cache is called the PersistentManager) that translates File GUIDs and Local IDs into simple, session-unique integers. These are called Instance IDs, and are assigned in a simple, monotonically-increasing order when new Objects are registered with the cache.
备注：打开*.meta文件里可以看到guid，但Local ID就没看到，以一个打包成图集的图片Asset为例，可以发现fileIDToRecycleName应该就是这个Local IDs。然而这个属性不是必然的。

（2）打成AssetBundle的Object在调用AssetBundle.Unload(false)，只会被卸载但不会从内存中移除，可以应用在这种需求：APP先被挂起并且强制退入后台，再返回到前台，然后Unity会在Scene恢复渲染前把全部所需的纹理、着色器和网格重新加载到GPU。
> If AssetBundle.Unload(false) is called, live Objects sourced from the unloaded AssetBundle will not be destroyed, but Unity will invalidate the File GUID and Local ID references of their Instance IDs. It will be impossible for Unity to reload these Objects if they are later unloaded from memory and live references to the unloaded Objects remain.
>
> The most common case where Objects are removed from memory at runtime without being unloaded occurs when Unity loses control of its graphics context. This may occur when a mobile app is suspended and the app is forced into the background. In this case, the mobile OS usually evicts all graphical resources from GPU memory. When the app returns to the foreground, Unity must reload all needed Textures, Shaders and Meshes to the GPU before scene rendering can resume.

（3-1）从存储设备读取预制体，哪怕是相同数据，也要重新进行读取文件，这种方法的加载操作受到存储设备I/O时间的限制，所以从内存中读取更优。

（3-2）我的理解是说AssetBundle比Resources优。

（4）在大多数平台上，用于查找的数据结构是平衡查找树，其时间复杂度为O(nlog(n))。因此，索引加载时间随Resources文件夹内Object数量而增长的速度高于线性增长。

（5-1）由序列化AssetBundle中的Asset而生成的原始数据，如果指定了压缩方案为LZMA，所有序列化的Asset会被压缩到一个字节数组中；如果指定了压缩方案为LZ4，不同Asset的字节数据会被单独压缩。

（5-2）在Unity 5.3之前的版本中，AssetBundle中的Object不能被单独压缩。因此，在5.3之前版本的Unity中，如果要从已压缩的AssetBundle中读取Object，引擎必须解压整个AssetBundle。通常情况下，Unity会缓存一份解压后的AssetBundle副本，以此来提高加载性能。

（5-3）我的理解就是说LZ4比LZMA优。

（6）从Unity 2017.1开始，WWW.LoadFromCacheOrDownload被封装到了UnityWebRequest中。因此，在使用Unity 2017.1或者更高版本进行开发时，应该使用UnityWebRequest。WWW.LoadFromCacheOrDownload会在将来的发行版中被废弃。

（7）通常情况下，应该优先使用 AssetBundle.LoadFromFile，这一API在速度、磁盘使用和运行时内存占用方面都很高效。如果项目必须下载AssetBundle，强烈推荐在Unity 5.3以及更新的版本中使用 UnityWebRequest。
